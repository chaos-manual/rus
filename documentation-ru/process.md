# Этапы работы 

> CE Process // Как мы работаем // Каркасный процесс

We describe a chaos engineering process starting 
from incident categorization and system research to 
hypothesis/well functioning tests. The process outcomes are team tasks 
for fixing failed tests and suites of green tests (to be invoked on new release).

## 1. Prepare // Подготовка

- начинаем с анализа истории инцидентов
- сводим к категориям инцидентов (grow up)
- делаем исследование (что на входе, что не выходе)
- строим гипотезы и планируем эксперименты в местах "где узко"
- используем группы атак (в том числе по сложности и стоимости подготовки тестов)

## 2. Test // Тестирование

- провели тесты, зафиксирвоали результаты
- получили в несколько итераций эталонные тесты 

## 3. Fix // Что делаем с результатами

- что считаем положительным или отрицательным результатом теста

Отрицательные тесты:

- задача на исследование команде (почему так получилось)
- распочковывание задач команде + проблемы + риски

Тесты, которые проходят:

- используем для анализа следующего релиза
- при необходимости - проводим на их основе аварийные учения


### Обсуждение 

- нужно показать в чем value всего процесса
- разные view на процесс: основные блоки, их детализация, почему именно так, а не по-другому
- обснование почему в такой последоватлеьности, а не от SLO
- обратим внимание, что сами тесты - самый короткий этап
- без чего вообще не работет этот пайплайн (например, мониторинг) 


---

## Введение (Intro)

Предлагаем рассмотреть процесс построения chaos engineering (CE) enterprise среде, базирующийся конечно же на опыте и практиках международного сообщества и адаптированный и доработанный для использования в больших корпорациях.  Мы взяли лучшие практики и связали их в одну последовательность и единую процесс-цепочку. 

## Почему это было необходимо сделать?

Конечно же если у Вас работает более 200 человек в команде которые в свою очередь организованы в  20-30 команд, которые работают над продуктом (хорошо, если над разными, а может быть и в рамках одного продукта). В данном случае выстроить chaos engineering и научить культуре команды довольно непростая задача. Собственно, сам процесс начинается далеко за пределами того, когда мы приходим к конкретной команде и начинаем с ними прорабатывать вопросы о проведении испытаний и планировать первые  GameDays далее в процесс вовлекаются разные команды Ops, Разработки, Архитекторы , Аналитики и др. далее процесс затронет такие важные моменты как работа с результатами, какие роли нужны для решения задач и как можно результаты связать с риск моделью на систему если это необходимо. 

##  Анализ инцидентов

Итак, сперва необходимо взять инциденты и проанализировать их на предмет того: как часто? где? и почему? происходят disasters. Конечно же мы не будем ставить перед собой цель повторить все эти инциденты, наша цель заключается в том, чтобы обогатить команды знаниями о том, в каких точках система максимально уязвима.
После того как инциденты проанализированы и разделены на категории, согласно определенным критериям (этому будет посвящен отдельный раздел в нашем мануале “Работа с инцидентами”),  мы переходим к процессу непосредственного изучения системы [made link to manual “Детализация системы”]. 

## Генерация гипотез

Затем мы переходим к процессу генерации гипотез, так как мы уже достаточно много изучили об инцидентах, а также о различных проблемах  в production среде. К тому времени, как мы собрали достаточно сведений и понимаем как выглядит система, знаем из каких частей она состоит, мы можем сгенерировать потенциальные точки, которые необходимо проверить с точки зрения атак. 

## Разработка и проведение испытаний

На этом этапе команда, которая разрабатывает АС (автоматизированную систему), совместно с командой chaos engineering прорабатывает сценарии атак. Почему часть работы происходит именно с командой? Потому что, она более детально и всесторонне знает свою систему.  И второе, команда проекта выполняет роль, которая позволяет привнести в общую команду информацию о мониторинге. 

## Анализ и обработка результатов

После того как мы провели испытания у нас на выходе проявятся такие случаи (cases): 

### Система сломалась, в результате сформировалась task (задача)

Рассмотрим случай, когда команда получает на вход task, с которой она будет дальше работать. Например, после испытания система где-то сломалась, и мы не смогли ее восстановить, в результате чего, появилась задача, которую нужно проработать.

### Система выдержала испытания

Второй случай, это когда система выдержала испытания. Это предполагает, что мы можем такое же испытание проводить уже в более сложной среде например, в production. Здесь следует, отметить важный пункт, что сам цикл испытаний начинается не в production. То есть не нужно сходу идти и ломать production, если вы еще не провели испытания в тестовой среде.
После того как часть тестов была успешно пройдена, они должны быть переведены в регрессионные испытания. Иногда компании, называют это аварийными учениями (более детальную информацию см. в разделе [Как проводить повторные испытания в production]).
Таски, с которыми мы столкнулись и при которых система сломалась в каких-то точках, мы передаем уже непосредственно в команды. Процессу работы с командами над тасками будет посвящен отдельный блок , в котором мы опишем роли, и то как команда может работать со сформированными тасками. В больших компаниях эти таски иногда превращаются в Риск модель (Model risk). Этому будет посвящен отдельный блок с информацией о том, как можно и нужно привязывать эти задачи к риск модели, как выявлять зависимости [link] 

 
## Преимущества chaos engineering 

Value всего процесса заключается в том, что:
- Мы проактивно ищем инциденты еще до их фактического наступления.
- Во время испытаний мы повышаем надежность системы. 

Ведь во время подготовки и проведения испытаний команды разработки и сопровождения, в первом случае, сразу пишут более надежную систему (т.е. дорабатывают какие-то внутренние инструменты of application). В случае сопровождения или operations team, чаще всего дорабатываются всевозможные Alert Wizards, системы мониторинга и т.д.
Давайте рассмотрим на различных примерах, почему необходимо строить блоки и процессы именно так как мы описали в этой главе, а не по-другому (так как большая часть из них была проверена на реальных командах).
